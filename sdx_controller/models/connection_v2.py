# coding: utf-8

from __future__ import absolute_import
from datetime import date, datetime  # noqa: F401

from typing import List, Dict  # noqa: F401

from sdx_controller.models.base_model_ import Model
from sdx_controller.models.connection_qos_metrics import ConnectionQosMetrics  # noqa: F401,E501
from sdx_controller.models.connection_scheduling import ConnectionScheduling  # noqa: F401,E501
from sdx_controller.models.connection_v2_endpoints import ConnectionV2Endpoints  # noqa: F401,E501
from sdx_controller.models.connection_v2_notifications import ConnectionV2Notifications  # noqa: F401,E501
from sdx_controller.models.link import Link  # noqa: F401,E501
from sdx_controller import util


class ConnectionV2(Model):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    def __init__(self, name: str=None, endpoints: List[ConnectionV2Endpoints]=None, description: str=None, notifications: List[ConnectionV2Notifications]=None, scheduling: ConnectionScheduling=None, qos_metrics: Dict[str, ConnectionQosMetrics]=None, paths: List[str]=None, status: str=None, complete: bool=False, quantity: int=None, multi_path: bool=None, preempt: bool=None, backup_path_type: str=None, exclusive_links: List[Link]=None, inclusive_links: List[Link]=None):  # noqa: E501
        """ConnectionV2 - a model defined in Swagger

        :param name: The name of this ConnectionV2.  # noqa: E501
        :type name: str
        :param endpoints: The endpoints of this ConnectionV2.  # noqa: E501
        :type endpoints: List[ConnectionV2Endpoints]
        :param description: The description of this ConnectionV2.  # noqa: E501
        :type description: str
        :param notifications: The notifications of this ConnectionV2.  # noqa: E501
        :type notifications: List[ConnectionV2Notifications]
        :param scheduling: The scheduling of this ConnectionV2.  # noqa: E501
        :type scheduling: ConnectionScheduling
        :param qos_metrics: The qos_metrics of this ConnectionV2.  # noqa: E501
        :type qos_metrics: Dict[str, ConnectionQosMetrics]
        :param paths: The paths of this ConnectionV2.  # noqa: E501
        :type paths: List[str]
        :param status: The status of this ConnectionV2.  # noqa: E501
        :type status: str
        :param complete: The complete of this ConnectionV2.  # noqa: E501
        :type complete: bool
        :param quantity: The quantity of this ConnectionV2.  # noqa: E501
        :type quantity: int
        :param multi_path: The multi_path of this ConnectionV2.  # noqa: E501
        :type multi_path: bool
        :param preempt: The preempt of this ConnectionV2.  # noqa: E501
        :type preempt: bool
        :param backup_path_type: The backup_path_type of this ConnectionV2.  # noqa: E501
        :type backup_path_type: str
        :param exclusive_links: The exclusive_links of this ConnectionV2.  # noqa: E501
        :type exclusive_links: List[Link]
        :param inclusive_links: The inclusive_links of this ConnectionV2.  # noqa: E501
        :type inclusive_links: List[Link]
        """
        self.swagger_types = {
            'name': str,
            'endpoints': List[ConnectionV2Endpoints],
            'description': str,
            'notifications': List[ConnectionV2Notifications],
            'scheduling': ConnectionScheduling,
            'qos_metrics': Dict[str, ConnectionQosMetrics],
            'paths': List[str],
            'status': str,
            'complete': bool,
            'quantity': int,
            'multi_path': bool,
            'preempt': bool,
            'backup_path_type': str,
            'exclusive_links': List[Link],
            'inclusive_links': List[Link]
        }

        self.attribute_map = {
            'name': 'name',
            'endpoints': 'endpoints',
            'description': 'description',
            'notifications': 'notifications',
            'scheduling': 'scheduling',
            'qos_metrics': 'qos_metrics',
            'paths': 'paths',
            'status': 'status',
            'complete': 'complete',
            'quantity': 'quantity',
            'multi_path': 'multi_path',
            'preempt': 'preempt',
            'backup_path_type': 'backup_path_type',
            'exclusive_links': 'exclusive_links',
            'inclusive_links': 'inclusive_links'
        }
        self._name = name
        self._endpoints = endpoints
        self._description = description
        self._notifications = notifications
        self._scheduling = scheduling
        self._qos_metrics = qos_metrics
        self._paths = paths
        self._status = status
        self._complete = complete
        self._quantity = quantity
        self._multi_path = multi_path
        self._preempt = preempt
        self._backup_path_type = backup_path_type
        self._exclusive_links = exclusive_links
        self._inclusive_links = inclusive_links

    @classmethod
    def from_dict(cls, dikt) -> 'ConnectionV2':
        """Returns the dict as a model

        :param dikt: A dict.
        :type: dict
        :return: The connection_v2 of this ConnectionV2.  # noqa: E501
        :rtype: ConnectionV2
        """
        return util.deserialize_model(dikt, cls)

    @property
    def name(self) -> str:
        """Gets the name of this ConnectionV2.


        :return: The name of this ConnectionV2.
        :rtype: str
        """
        return self._name

    @name.setter
    def name(self, name: str):
        """Sets the name of this ConnectionV2.


        :param name: The name of this ConnectionV2.
        :type name: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501

        self._name = name

    @property
    def endpoints(self) -> List[ConnectionV2Endpoints]:
        """Gets the endpoints of this ConnectionV2.


        :return: The endpoints of this ConnectionV2.
        :rtype: List[ConnectionV2Endpoints]
        """
        return self._endpoints

    @endpoints.setter
    def endpoints(self, endpoints: List[ConnectionV2Endpoints]):
        """Sets the endpoints of this ConnectionV2.


        :param endpoints: The endpoints of this ConnectionV2.
        :type endpoints: List[ConnectionV2Endpoints]
        """
        if endpoints is None:
            raise ValueError("Invalid value for `endpoints`, must not be `None`")  # noqa: E501

        self._endpoints = endpoints

    @property
    def description(self) -> str:
        """Gets the description of this ConnectionV2.


        :return: The description of this ConnectionV2.
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description: str):
        """Sets the description of this ConnectionV2.


        :param description: The description of this ConnectionV2.
        :type description: str
        """

        self._description = description

    @property
    def notifications(self) -> List[ConnectionV2Notifications]:
        """Gets the notifications of this ConnectionV2.


        :return: The notifications of this ConnectionV2.
        :rtype: List[ConnectionV2Notifications]
        """
        return self._notifications

    @notifications.setter
    def notifications(self, notifications: List[ConnectionV2Notifications]):
        """Sets the notifications of this ConnectionV2.


        :param notifications: The notifications of this ConnectionV2.
        :type notifications: List[ConnectionV2Notifications]
        """

        self._notifications = notifications

    @property
    def scheduling(self) -> ConnectionScheduling:
        """Gets the scheduling of this ConnectionV2.


        :return: The scheduling of this ConnectionV2.
        :rtype: ConnectionScheduling
        """
        return self._scheduling

    @scheduling.setter
    def scheduling(self, scheduling: ConnectionScheduling):
        """Sets the scheduling of this ConnectionV2.


        :param scheduling: The scheduling of this ConnectionV2.
        :type scheduling: ConnectionScheduling
        """

        self._scheduling = scheduling

    @property
    def qos_metrics(self) -> Dict[str, ConnectionQosMetrics]:
        """Gets the qos_metrics of this ConnectionV2.


        :return: The qos_metrics of this ConnectionV2.
        :rtype: Dict[str, ConnectionQosMetrics]
        """
        return self._qos_metrics

    @qos_metrics.setter
    def qos_metrics(self, qos_metrics: Dict[str, ConnectionQosMetrics]):
        """Sets the qos_metrics of this ConnectionV2.


        :param qos_metrics: The qos_metrics of this ConnectionV2.
        :type qos_metrics: Dict[str, ConnectionQosMetrics]
        """

        self._qos_metrics = qos_metrics

    @property
    def paths(self) -> List[str]:
        """Gets the paths of this ConnectionV2.


        :return: The paths of this ConnectionV2.
        :rtype: List[str]
        """
        return self._paths

    @paths.setter
    def paths(self, paths: List[str]):
        """Sets the paths of this ConnectionV2.


        :param paths: The paths of this ConnectionV2.
        :type paths: List[str]
        """

        self._paths = paths

    @property
    def status(self) -> str:
        """Gets the status of this ConnectionV2.

        Connection Status  # noqa: E501

        :return: The status of this ConnectionV2.
        :rtype: str
        """
        return self._status

    @status.setter
    def status(self, status: str):
        """Sets the status of this ConnectionV2.

        Connection Status  # noqa: E501

        :param status: The status of this ConnectionV2.
        :type status: str
        """
        allowed_values = ["success", "fail", "scheduled", "provisioining"]  # noqa: E501
        if status not in allowed_values:
            raise ValueError(
                "Invalid value for `status` ({0}), must be one of {1}"
                .format(status, allowed_values)
            )

        self._status = status

    @property
    def complete(self) -> bool:
        """Gets the complete of this ConnectionV2.


        :return: The complete of this ConnectionV2.
        :rtype: bool
        """
        return self._complete

    @complete.setter
    def complete(self, complete: bool):
        """Sets the complete of this ConnectionV2.


        :param complete: The complete of this ConnectionV2.
        :type complete: bool
        """

        self._complete = complete

    @property
    def quantity(self) -> int:
        """Gets the quantity of this ConnectionV2.


        :return: The quantity of this ConnectionV2.
        :rtype: int
        """
        return self._quantity

    @quantity.setter
    def quantity(self, quantity: int):
        """Sets the quantity of this ConnectionV2.


        :param quantity: The quantity of this ConnectionV2.
        :type quantity: int
        """

        self._quantity = quantity

    @property
    def multi_path(self) -> bool:
        """Gets the multi_path of this ConnectionV2.


        :return: The multi_path of this ConnectionV2.
        :rtype: bool
        """
        return self._multi_path

    @multi_path.setter
    def multi_path(self, multi_path: bool):
        """Sets the multi_path of this ConnectionV2.


        :param multi_path: The multi_path of this ConnectionV2.
        :type multi_path: bool
        """

        self._multi_path = multi_path

    @property
    def preempt(self) -> bool:
        """Gets the preempt of this ConnectionV2.


        :return: The preempt of this ConnectionV2.
        :rtype: bool
        """
        return self._preempt

    @preempt.setter
    def preempt(self, preempt: bool):
        """Sets the preempt of this ConnectionV2.


        :param preempt: The preempt of this ConnectionV2.
        :type preempt: bool
        """

        self._preempt = preempt

    @property
    def backup_path_type(self) -> str:
        """Gets the backup_path_type of this ConnectionV2.


        :return: The backup_path_type of this ConnectionV2.
        :rtype: str
        """
        return self._backup_path_type

    @backup_path_type.setter
    def backup_path_type(self, backup_path_type: str):
        """Sets the backup_path_type of this ConnectionV2.


        :param backup_path_type: The backup_path_type of this ConnectionV2.
        :type backup_path_type: str
        """
        allowed_values = ["0", "1", "2", "3"]  # noqa: E501
        if backup_path_type not in allowed_values:
            raise ValueError(
                "Invalid value for `backup_path_type` ({0}), must be one of {1}"
                .format(backup_path_type, allowed_values)
            )

        self._backup_path_type = backup_path_type

    @property
    def exclusive_links(self) -> List[Link]:
        """Gets the exclusive_links of this ConnectionV2.


        :return: The exclusive_links of this ConnectionV2.
        :rtype: List[Link]
        """
        return self._exclusive_links

    @exclusive_links.setter
    def exclusive_links(self, exclusive_links: List[Link]):
        """Sets the exclusive_links of this ConnectionV2.


        :param exclusive_links: The exclusive_links of this ConnectionV2.
        :type exclusive_links: List[Link]
        """

        self._exclusive_links = exclusive_links

    @property
    def inclusive_links(self) -> List[Link]:
        """Gets the inclusive_links of this ConnectionV2.


        :return: The inclusive_links of this ConnectionV2.
        :rtype: List[Link]
        """
        return self._inclusive_links

    @inclusive_links.setter
    def inclusive_links(self, inclusive_links: List[Link]):
        """Sets the inclusive_links of this ConnectionV2.


        :param inclusive_links: The inclusive_links of this ConnectionV2.
        :type inclusive_links: List[Link]
        """

        self._inclusive_links = inclusive_links
